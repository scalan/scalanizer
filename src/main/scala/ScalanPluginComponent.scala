package scalan.plugin

import scala.tools.nsc._
import scala.tools.nsc.plugins.PluginComponent
import scala.tools.nsc.transform.{TypingTransformers, Transform}
import scalan.meta.ScalanAst.SEntityModuleDef
import scalan.meta.{ScalanParsers, CodegenConfig, ScalanCodegen}
import scalan.util.Serialization

object ScalanPluginComponent {
  val name = "scalan-final"
}

class ScalanPluginComponent(val global: Global)
  extends PluginComponent with TypingTransformers with Transform
  with ScalanParsers with Enricher with HotSpots with Backend {

  import global._

  val phaseName: String = ScalanPluginComponent.name
  override def description: String = "Code virtualization and specialization"

  val runsAfter = List(CheckExtensions.name)

  def newTransformer(unit: CompilationUnit) = new ScalanModuleTransformer(unit)

  /** Transformations of Scalan AST */
  val pipeline = scala.Function.chain(Seq(
    fixExistentialType _,
    externalTypeToWrapper _,
    composeParentWithExt _,
    addModuleAncestors _, addEntityAncestors _,
    updateSelf _,
    repSynonym _,
    addImports _,
    checkEntityCompanion _, checkClassCompanion _,
    cleanUpClassTags _, replaceClassTagByElem _, eliminateClassTagApply _,
    genEntityImpicits _, genClassesImplicits _, genMethodsImplicits _,
    fixEntityCompanionName _,
    fixEvidences _
  ))

  def showTree(prefix: String, name: String, tree: Tree) =
    saveDebugCode(prefix + "_" + name, showCode(tree))

  class ScalanModuleTransformer(unit: CompilationUnit) extends TypingTransformer(unit) {

    override def transform(tree: Tree): Tree = tree match {
      case PackageDef(n, stats) =>
        val unitName = unit.source.file.name
        if (false && ScalanPluginConfig.codegenConfig.entityFiles.contains(unitName)) try {
          //        showTree("body", unitName, tree)
          val moduleDef = parse(unitName, tree)
          val enrichedModuleDef = pipeline(moduleDef)

          /** Generates a virtualized version of original Scala AST, wraps types by Rep[] and etc. */
          val virtAst = genScalaAst(enrichedModuleDef, tree)
          //        showTree("virtAst", unitName, virtAst)

          /** Invoking of Scalan META to produce boilerplate code */
          val boilerplate = genBoilerplate(enrichedModuleDef)
          //        showTree("boilerplate", unitName, boilerplate)

          /** Checking of user's extensions like SegmentDsl, SegmentDslStd and SegmentDslExp */
          val extensions: List[Tree] = getExtensions(moduleDef)
          //        for ((e,i) <- extensions.zipWithIndex)
          //          showTree(s"extensions$i", unitName, e)

          /** Serialize Virtualized AST for passing to run-time. */
          val serializedModuleDef = serializeModuleDef(moduleDef)
          //        showTree("serializedAst", unitName, serializedModuleDef)

          /** Replace of hot spots by optimized kernels in the original Scala AST of current compilation unit. */
          val accelAst = transformHotSpots(moduleDef, unit)
          //        showTree("accelAst", unitName, accelAst)

          /** Staged Ast is package which contains virtualized Tree + boilerplate */
          val objectHotSpotKernels = getHotSpotKernels(moduleDef)
          val objectHotSpotManager = getHotSpotManager(moduleDef)
          val stagedAst = getStagedAst(
            moduleDef, virtAst, boilerplate, extensions, serializedModuleDef,
            objectHotSpotKernels,
            objectHotSpotManager)
          //        showTree("stagedAst", unitName, stagedAst)

          if (ScalanPluginConfig.save) {
            //          saveImplCode(unit.source.file.file, showCode(stagedAst))
          }


          val res = if (ScalanPluginConfig.read) {
            /** Discards the generated code and load it from FS. */
            accelAst
          }
          else
          {
            combineAst(accelAst, stagedAst)
          }

          if (ScalanPluginConfig.debug)
            saveDebugCode(unitName, showCode(tree))

          val typed = localTyper.typed(res)
          typed
        } catch {
          case e: Exception =>
            print(s"Error: failed to scalanize ${unitName} due to " + e.printStackTrace())
            throw e
        }
        else
          tree
//      case PackageDef(n, stats) =>
//        print(s"PackageDef($n, $stats")
//        tree
    }
  }

  /** Puts all staff in one place. Here is an example for the Cols module:
    *  package scalanizer.collections {
    *  package implOfCols {
    *    object StagedEvaluation {
    *      // Virtualized code (virtAst)
    *      trait Cols extends Base {...}
    *      // Boilerplate generated by scalan-meta (boilerplate)
    *      trait ColsAbs extends ScalanDsl with Cols {...}
    *      trait ColsExp extends ScalanExp with ColsDsl {...}
    *      // Auto-generated extensions (extensions)
    *      trait ColsDsl extends ColsAbs {...}
    *      trait ColsDslExp extends ColsExp {...}
    *      // Module AST converted to string (serial)
    *      val serializedMetaAst = "..."
    *    }
    *    // Virtualized hot spots of the module and related staff (hotSpotKernels, hotSpotManager)
    *    object HotSpotKernels {...}
    *    object HotSpotManager {...}
    *  }}
    * */
  def getStagedAst(origModuleDef: SEntityModuleDef,
                   virtAst: Tree,
                   boilerplate: Tree,
                   extensions: List[Tree],
                   serial: Tree,
                   hotSpotKernels: Tree, hotSpotManager: Tree): Tree =
  {
    val (imports, implStats) = boilerplate match {
      case PackageDef(_, topstats) =>
        val imports = topstats.collect { case i @ Import(_,_) => i }
        val implStatsOpt = topstats.collectFirst { case q"package impl { ..$stats }" => stats }
        (imports, implStatsOpt match {
          case Some(stats) => stats
          case None => !!!(s"Tree doesn't have correct structure: ${showCode(boilerplate)}")
        })
    }
    virtAst match {
      case PackageDef(pkgName, declStats) =>
        val body = declStats ++ implStats ++ extensions ++ List(serial)
        val stagedObj = q"object StagedEvaluation {..$body}"

        PackageDef(pkgName,
          List(PackageDef(
            Ident(TermName("implOf"+origModuleDef.name)),
            imports ++ List(stagedObj, hotSpotKernels, hotSpotManager)
          ))
        )
    }
  }

  /** Puts original and virtualized entity code together. For example:
    * package scalanizer.linalgebra {
    *   trait Matrs {self: LinearAlgebra => }
    * }
    * and the result of the getStagedAst method are combined into:
    * package scalanizer.linalgebra {
    *   trait Matrs {self: LinearAlgebra => ...}
    *   package implOfMatrs {...}
    * }
    * */
  def combineAst(orig: Tree, staged: Tree): Tree = {
    val stagedStats = staged match {
      case q"package $_ { ..$stats }" => stats
    }
    val newTree = orig match {
      case q"package $pkgname { ..$stats }" =>
        q"package $pkgname { ..${stats.toList ++ stagedStats} }"
      case _ => orig
    }
    newTree
  }

  /** Generates extensions like:
    *   trait MatrsDsl extends MatrsAbs { self: LinearAlgebraDsl => };
    *   trait MatrsDslExp extends MatrsExp { self: LinearAlgebraDslExp => };
    * for the module (Matrs).
    */
  def getExtensions(module: SEntityModuleDef): List[Tree] = {
    genModuleExtensions(module).map(extTrait => genTrait(extTrait)(GenCtx(module, false)))
  }

  /** Converts Meta AST of a module to base64 string, assings the string to a variable and
    * returns Scala Tree of the variable. */
  def serializeModuleDef(module: SEntityModuleDef): Tree = {
    val str = if (ScalanPluginConfig.saveMetaAst) {
      val erasedModule = eraseModule(module)
      Serialization.save(erasedModule)
    } else ""
    val serialized = Literal(Constant(str))

    q"val serializedMetaAst = $serialized"
  }
}
